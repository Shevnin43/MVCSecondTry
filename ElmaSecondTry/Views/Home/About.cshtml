
    <h2>Программа кадровое агентство создано на основе тестового задания компании «Элма».</h2>
    <h4>Структура:</h4>
    <p>
        Решение разделено на три проекта:
        <ol style="text-align:justify">
            <li>
                <strong>ElmaSecondTry.Base</strong> — Определяет базовые сущности, используемые в решении, перечисления, определяющие некоторые свойства объектов, а также интерфейсы репозиториев, определяющих методы работы с хранилищем (в нашем случае — база данных SQL) решения, отвечающего за обмен данными с внешним хранилищем (в нашем случае — ElmaSecondTry.NHibernate). А сейчас немного конкретики…
                <ul>
                    <li>
                        Сущности. В данном решении объявлены следующие сущности:
                        <ul>
                            <li>
                                UserBase - определяет ЛЮБОГО пользователя системы независимо от его роли (даже пользователя без роли), целей, задач и пожеланий. Имеет обобщенные характеристики для всех пользователей, а так же свойство Role пользователя, определяющего возможности пользователя в системе. Кроме того, любой пользователь может иметь список объявлений (свойство ICollection&lt;IAnnouncement&gt;) БЕЗ УКАЗАНИЯ ТИПА объявлений. Т.е. данное свойство гарантирует пользователю возможность иметь объявления различных типов, реализующих интерфейс IAnnouncement. Контроль наличия у пользователя объявлений только того типа который позволяет иметь роль в данном проекте не реализован. Такой контроль реализован в проекте ElmaSecondTry. Свойство NotKill введено для ограничения возможности удаления отдельных пользователейб т.е. пользователей, у которых установлено данное свойство нельзя удалить из программы. Данное свойство никак не устанавливается в программе, установить/снять его можно только напрямую в базе данных;
                            </li>
                            <li>
                                IAnnouncement — интерфейс, определяющий общие свойства для всех типов объявлений, позволяющих добавлять данное объявление пользователю в упомянутое выше свойство ICollection &lt;IAnnouncement&gt; сущности UserBase. Данное решение было принято для обеспечения унификации объявлений в случае, например, если возникнет необходимость добавить еще какой-нибудь тип объявления в решение. Т.е. в сущности UserBase не будет необходимости добавлять новое свойство для нового типа объявлений, новый тип объявления, при условии реализации интерфейса, получит право на добавление в ICollectuon&lt;IAnnouncement&gt; сущности UserBase (в зависимости от роли пользователя, конечно). Пользователь может иметь только объявления, реализующие данный интерфейс, соответственно все вновь вводимые объявления обязаны реализовать интерфейс и иметь определенные свойства. Также рассматривался вариант применения вместо интерфейса IAnnouncement родительского класса Announcement, но выбор все-таки пал на интерфейс, хотя применение родительского класса вполне достойное решение… возможно даже лучше;
                            </li>
                            <li>
                                CandidateBase — собственно сущность объявления типа Кандидат, реализующий интерфейс IAnnouncement. Определяет свойства объявления … тут нет ничего интересного;
                            </li>
                            <li>
                                VacancyBase — сущность объявления типа Вакансия, также реализует интерфейс IAnnouncement и определяет свойства вакансии. Из интересного тут можно отметить контроль валидности объявления в зависимости от срока действия объявления. Пользователь, являющийся владельцем объявления данного типа никак не управляет напрямую свойством IsOpen, повлиять на данное свойство он может только регулируя срок действия объявления а данное свойство устанавливается автоматически в зависимости от срока и текущей даты.
                            </li>
                            <li>
                                RepositoryResult — класс призванный унифицировать все возвращаемые результаты методов репозиториев. Содержит в себе как сообщение об ошибке (в случае возникновения исключения или ошибки при выполнении операций с базой данных), так и возвращаемые в результате выполнения запросов объекты различных типовб а так же статус результата выполнения операции: ошибка, предупреждение, успех и фатальная ошибка (при возникновении исключения).
                            </li>
                        </ul>
                    </li>
                    <li>
                        Перечисления:
                        <ul>
                            <li>
                                UserRoles — собственно роли, присваиваемые пользователям. На основе этих ролей регламентируются возможности пользователя в системе. Изначально было принято решение сделать роли типом перечисления. В представленной реализации этого вполне достаточно, но если вы спросите меня «Что бы вы еще добавили или как-то усовершенствовали Вашу систему? (а при первой попытке реализовать аналогичное тестовое задание именно такой вопрос и был задан) я бы ответил: переопределил бы систему аутентификации пользователя, т.к. не всегда удобно использовать штатную систему (например мне в некоторых местах неудобно было постоянно спрашивать User.IsInRole(«бла-бла») чтобы определить роль пользователя). Соответственно при переопределении системы аутентификации я бы реализовал свойство Role в виде отдельной сущности и добавил ей bool свойства, например CanHaveVacancyes или CanHaveCandidates или CanUserManage или CanSeeVacancyes или CanSeeCandidates. В данном случае стало бы намного удобнее работать с ролями пользователей и очень просто и безопасно вводить новые роли со своими относительно уникальными «правами»;
                            </li>
                            <li>
                                AnnouncementType — перечисление доступных в системе типов объявлений, в данной реализации — Vacancyes и Candidates. Интерфейс IAnnouncement имеет свойство для конкретизации типа объявления, находящегося в списке объявлений пользователя;
                            </li>
                            <li>
                                TimesJob — занятость, указываемая в объявлении Вакансии.
                            </li>
                        </ul>
                    </li>
                    <li>
                       Интерфейсы репозиториев — определяют какие методы и свойства должны содержать репозитории для обмена данными с хранилищем (БД):
                        <ul>
                            <li>
                                IUserRepository — методы и свойства, которые должен реализовать репозиторий для обмена данными сущности UserBase с хранилищем. Т.е. все методы которые могут пригодиться при создании, извлечении, редактировании, удалении (CRUD) и выборке пользователя;
                            </li>
                            <li>
                                IAnnouncementRepository — методы и свойства, которые должен реализовать репозиторий для работы с объявлениями. Методы универсальны и используются для обоих видов объявлений. Для каждого метода требуют возвращать ответ в виде RepositoryResult, упомянутый в разделе "сущности".
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <strong>Проект ElmaSecondTry.NHibernate</strong> — решение, обеспечивающее обмен данными с хранилищем (БД). Функцию обмена данными можно условно разделить на две функции: функция маппинга (отображения) объектной модели решения ElmaSecondTry.Base в реляционную модель базы данных и обратно и непосредственно обмен данными (CRUD + select). Cодержит в себе класс настройки NHibernate, реализации интерфейсов IUserRepository и IAnnouncementRepository (UserRepository и  AnnouncementRepository соответственно) и файлы маппинга сущностей ElmaSecondTry.Base в базу данных. Маппятся сущности UserBase, IAnnouncement, CandidateBase и VacancyBase (VacancyBase и CandidateBase маппятся к IAnnouncement как JoinedClass для  того чтобы не раздувать таблицу IAnnouncement). Для данного проекта решено использовать маппинг в коде вместо маппинга в xml файлах или маппинга в атрибутах. Долго не мог решить как разграничить зону ответственности по подготовке объектов для базы данных. В итоге решено все данные готовить в проекте ElmaSecondTry а в репозитории направлять уже подготовленные модели. Т.е. зона ответственности репозиториев — непосредственный обмен с хранилищем.
            </li>
            <li>
                <strong>Проект ElmaSecondTry</strong> — самое объемное, сложное и трудоемкое решение. Постараюсь описать все что смогу по порядку:
                <ul>
                    <li>
                        Данный проект предназначен для обмена данными с клиентской частью (представлениями). В проекте используются собственные модели, которые, собственно, и передаются клиенту. Т.е. сущности базового проекта ElmaSecondTry.Base напрямую клиенту (и обратно) не передаются. Для отображения все модели базового проекта маппятся на модели данного проекта и модели, полученые из представления маппятся в модели базового проекта для дальнейшей работы с хранилищем данных.
                    </li>
                    <li>
                        Для маппинга моделей базового проекта ElmaSecondTry.Base в модели данного проекта и обратно применен пакет AutoMapper. В классе настройки маппинга Mappings указаны классы, которые могут маппиться друг на друга с некоторыми условиями и ограничениями и, когда нам это необходимо, — вызываем метод маппинга и получаем модель проекта ElmaSecondTry, свойства которой спроецированы из одноименных свойств модели ElmaSecondTryB.Base. Очень удобно.
                    </li>
                    <li>
                        Одной из введенных мною особенностей, которая не указана в тех.задании как обязательна к исполнению — DependencyInjection. Познакомился с этой технологией относительно недавно, но в проектах MVC не применял, применял только в ASP NET.Core. Данный проект — первый из MVC где мною применена данная технология. Для введения внедрения зависимостей в решение, был подключен пакет Ninject, который позволяет реализовать данную технологию.  Соответственно в классе настройки NinjectDependencyResolver были подключены реализации соответствующих интерфейсов (например IUserRepository, IAnnouncementRepository и IMapper) в качестве сервисов, которые в дальнейшем извлекаются в конструкторах контроллеров проекта для использования по мере необходимост. Только в одном месте - в классе CustomRoleProvider (о нем чуть позже) пришлось использовать сервис не в конструкторе а извлекать из коллекции сервисов вручную лишь потому, что в данном классе требовалось наличие пассивного конструктора без параметров. Даже в проекте ElmaSecondTry.NHibernate применяется DependencyInjection для использования SessionFactory.
                    </li>
                    <li>
                        Модели данного проекта старался разбивать таким образом, чтобы в клиентскую часть не уходили данные, не предназначенные для клиента (например пароль пользователя никогда не маппится на модель, которая направляется в представление как для отображения так и редактирования данных). Для выборки пользователей и объявлений введены отдельные модели, которые содержат в себе минимальные и максимальные значения выбираемых данных. Далее такие параметры направляются в ElmaSecondTry.NHibernate в качестве словаря значений Dictionary&lt;string,object&gt;.
                    </li>
                    <li>
                        В качестве представлений используются строго типизированные представления и частичные представления PartialView. Применены стандартные представления, автоматически генерируемые для отображения/редактирования моделей, в связи с чем основа отобрадаемых данных — Html Хэлперы, за исключением тех элементов, отображение которых средствами Html хэлперов было неудобно. В некоторых представлениях применены java скрипты для обработки информации непосредственно на клиенте (например на форме выборки объявлений) и Ajax — для динамического обновления данных (для отображения результатов выборки пользователей).
                    </li>
                    <li>
                        Контроллеры, как уже говорилось ранее, в своем конструкторе получают необходимые для работы сервисы и используют их в любом методе контроллера. В каждом контроллере имеется метод MessageForClient, в который передаются сообщения для пользователя с соответствующим статусом выполняемой операции. Для передачи информации в представление используется TempData. Отображение сообщений происходит при перезагрузке Layout вызовом модального окна с передачей ему необходимых данных. Так же контроллеры берут на себя ответственность по подготовке моделей для репозитория. Т.е. в репозиторий направляются уже подготовленные для хранилища модели. Соответственно из репозитория контроллеры получают модели НЕ подготовленные для отображения. В контроллерах реализовано ограничение доступа как к контроллерам в целом ([Authorizen]), так и к отдельным методам (в соответствии с ролями).
                    </li>
                    <li>
                        Добавлен класс General, в котором находятся некоторые «справочные» данные, используемые в проекте.
                    </li>
                    <li>
                        Для работы с ролями был переопределен класс RoleProvider как CustomRoleProvider.
                    </li>
                    <li>
                        Реализована аутентификация в режиме Forms.
                    </li>
                </ul>
            </li>
        </ol>
                В качестве резюме хотел бы написать что именно я бы добавил, если бы данный проект был коммерческим, предназначенным для практического применения:
        <ol style="text-align:justify">
            <li>
                Переопределение системы аутентификации;
            </li>
            <li>
                Реализацию ролей в качестве отдельной сущности со свойствами типа bool , обеспечивающими более удобную работу с разрешениями для конкретных ролей.;
            </li>
            <li>
                Задумался бы в сторону асинхронности методов работы методов репозиториев для обмена данными с хранилищем.
            </li>
            <li>
                Данное решение имеет относительно небольшую бизнес-логику, заключающуюся в сопоставлении пользователей с их правами и возможностей системы (например возможности иметь объявления того или иного типа, возможности управлять пользователями), данная ответственность возложена на контроллеры проекта ElmaSecondTry. При необходимости внедрения более сложной логики, наверное, было бы целесообразно ввести дополнительный проект (слой) ответственный именно за бизнес-логику решения.
            </li>
        </ol>
            
        
    </p>
