@{
    ViewBag.Title = "About";
}
<h2>@ViewBag.Title.</h2>
<h3>@ViewBag.Message</h3>

<p>
    Программа кадровое агентство создано на основе тестового задания компании «Элма».
    Структура:
    Решение разделено на три проекта:

    ElmaSecondTry.Base — Определяет базовые сущности, используемые в решении, перечисления, определяющие некоторые свойства объектов, а также интерфейсы репозиториев, определяющих методы работы с хранилищем (в нашем случае — база данных SQL) решения, отвечающего за обмен данными с внешним хранилищем (в нашем случае — ElmaSecondTry.NHibernate). А сейчас немного конкретики…
    1.1. Сущности. В данном решении объявлены следующие сущности:
    - UserBase - определяет ЛЮБОГО пользователя системы независимо от его роли (даже пользователя без роли), целей, задач и пожеланий. Имеет обобщенные характеристики для всех пользователей, а так же свойство Роль пользователя, определяющего возможности пользователя в системе. Кроме того, любой пользователь может иметь список объявлений (свойство ICollection<IAnnouncement>
      ) БЕЗ УКАЗАНИЯ ТИПА объявлений. Т.е. данное свойство гарантирует пользователю возможность иметь объявления различных типов, реализующих интерфейс IAnnouncement. Добавление объявлений возможно только методом AddAnnouncement, что обеспечивает контроль и регулирование возможности пользователю иметь объявления только определенных типов. Кроме того, данный контроль обеспечивается и при изменении свойства Role пользователя;
    - IAnnouncement — интерфейс, определяющий общие свойства для всех типов объявлений, позволяющих добавлять данное объявление пользователю в упомянутое выше свойство ICollection<IAnnouncement>
      сущности UserBase. Данное решение было принято для обеспечения унификации объявлений в случае, например, если возникнет необходимость добавить еще какой-нибудь тип объявления в решение. Т.е. в сущности UserBase не будет необходимости добавлять новое свойство для нового типа объявлений, новый тип объявления, при условии реализации интерфейса, получит право на добавление в ICollectuon<IAnnouncement>
      сущности UserBase (в зависимости от роли пользователя, конечно). Пользователь может иметь только объявления, реализующие данный интерфейс, соответственно все вновь вводимые объявления обязаны реализовать интерфейс и иметь определенные свойства. Также рассматривался вариант применения вместо интерфейса IAnnouncement родительского класса Announcement, но выбор все-таки пал на интерфейс, хотя применение родительского класса вполне достойное решение… возможно даже лучше;
    - CandidateBase — собственно сущность объявления типа Кандидат, реализующий интерфейс IAnnouncement. Определяет свойства объявления… тут нет ничего интересного;
    - VacancyBase — сущность объявления типа Кандидат, также реализует интерфейс IAnnouncement и определяет свойства кандидата … то же ничего интересного.
    - RepositoryResult — класс призванный унифицировать все возвращаемые результаты методов репозиториев. Содержит в себе как сообщение об ошибке (в случае возникновения исключения или ошибки при выполнении операций с базой данных), так и возвращаемые в результате выполнения запросов объекты различных типов.
    1.2 Перечисления:
    - UserRoles — собственно роли, присваиваемые пользователям. На основе этих ролей регламентируются возможности пользователя в системе. Изначально было принято решение сделать роли типом перечисления. В представленной реализации этого вполне достаточно, но если вы спросите меня «Что бы вы еще добавили или как-то усовершенствовали Вашу систему? (а при первой попытке реализовать аналогичное тестовое задание именно такой вопрос и был задан) я бы ответил: переопределил бы систему аутентификации пользователя, т.к. не всегда удобно использовать штатную систему (например мне в некоторых местах неудобно было постоянно спрашивать User.IsInRole(«бла-бла») чтобы определить роль пользователя). Соответственно при переопределении системы аутентификации я бы реализовал свойство Role в виде отдельной сущности и добавил ей bool свойства, например CanHaveVacancyes или CanHaveCandidates или CanUserManage или CanSeeVacancyes или CanSeeCandidates. В данном случае стало бы намного удобнее работать с ролями пользователей и очень просто и безопасно вводить новые роли со своими относительно уникальными «правами»;
    - AnnouncementType — перечисление доступных в системе типов объявлений, в данной реализации — Vacancyes и Candidates. Интерфейс IAnnouncement имеет свойство для конкретизации типа объявления, находящегося в списке объявлений пользователя;
    - TimesJob — занятость, указываемая в объявлении Вакансии.
    1.3 Интерфейсы репозиториев — определяют какие методы и свойства должны содержать репозитории для обмена данными с хранилищем (БД):
    - IUserRepository — методы и свойства, которые должен реализовать репозиторий для обмена данными сущности UserBase с хранилищем. Т.е. все методы которые могут пригодиться при создании, извлечении, редактировании, удалении (CRUD) и выборке пользователя;
    - IAnnouncementRepository — методы и свойства, которые должен реализовать репозиторий для работы с объявлениями. Методы универсальны и используются для обоих видов объявлений.

    Проект ElmaSecondTry.NHibernate — решение, обеспечивающее обмен данными с хранилищем (БД). Функцию обмена данными можно условно разделить на две функции: функция маппинга (отображения) объектной модели решения ElmaSecondTry.Base в реляционную модель базы данных и обратно и непосредственно обмен данными (CRUD + select). Cодержит в себе класс настройки NHibernate, реализации интерфейсов IUserRepository и IAnnouncementRepository (UserRepository и  AnnouncementRepository соответственно) и файлы маппинга сущностей ElmaSecondTry.Base в базу данных. Маппятся сущности UserBase, IAnnouncement, CandidateBase и VacancyBase (VacancyBase и CandidateBase маппятся к IAnnouncement как JoinedClass для  того чтобы не раздувать таблицу IAnnouncement). Для данного проекта решено использовать маппинг в коде вместо маппинга в xml файлах или маппинга в атрибутах. Долго не мог решить как разграничить зону ответственности по подготовке моделей для базы данных. В итоге решено все данные готовить в проекте ElmaSecondTry а в репозитории направлять уже подготовленные модели. Т.е. зона ответственности репозиториев — непосредственный обмен с хранилищем.

    Проект ElmaSecondTry — самое объемное, сложное и трудоемкое решение. Постараюсь описать все что смогу по порядку:
    3.1 Данный проект предназначен для обмена данными с клиентской частью (представлениями). В проекте используются собственные модели, которые, собственно, и передаются клиенту. Т.е. сущности базового проекта ElmaSecondTry.Base напрямую клиенту (и обратно) не передаются. Для отображения все модели базового проекта маппятся на модели данного проекта и модели, полученые из представления маппятся в модели базового проекта для дальнейшей работы с хранилищем данных.
    3.2 Для маппинга моделей базового проекта ElmaSecondTry.Base в модели данного проекта и обратно применен пакет AutoMapper. В классе настройки маппинга … указаны классы, которые могут маппиться друг на друга и, когда нам это необходимо, — вызываем метод маппинга и получаем модель проекта ElmaSecondTry, свойства которой спроецированы из одноименных свойств модели ElmaSecondTryB.Base. Очень удобно.
    3.3 Одной из введенных мною особенностей, которая не указана в тех.задании как обязательна к исполнению — DependencyInjection. Познакомился с этой технологией относительно недавно, но в проектах MVC не применял, применял только в ASP NET.Core. Данный проект — первый из MVC где мною применена данная технология. Для введения внедрения зависимостей в решение, был подключен пакет Ninject, который позволяет реализовать данную технологию.  Соответственно в классе настройки … были подключены реализации соответствующих интерфейсов (например IUserRepository, IAnnouncementRepository и IMapper) в качестве сервисов, которые в дальнейшем извлекаются в конструкторах контроллеров проекта для использования по мере необходимости (только в одном месте !!! пришлось использовать сервис не в конструкторе а извлекать из коллекции сервисов вручную лишь потому, что в данном классе требовалось наличие пассивного конструктора без параметров). Даже в проекте ElmaSecondTry.NHibernate применяется DependencyInjection для использования SessionFactory.
    3.4 Модели данного проекта старался разбивать таким образом, чтобы в клиентскую часть не уходили данные, не предназначенные для клиента (например пароль пользователя никогда не маппится на модель, которая направляется в представление как для отображения так и редактирования данных). Для выборки пользователей и объявлений введены отдельные модели, которые содержат в себе минимальные и максимальные значения выбираемых данных. Далее такие параметры направляются в ElmaSecondTry.NHibernate в качестве словаря значений.
    3.5 В качестве представлений используются строго типизированные представления и частичные представления PartialView. Применены стандартные представления, автоматически генерируемые для отображения/редактирования моделей, в связи с чем основа отобрадаемых данных — Html Хэлперы, за исключением тех элементов, отображение которых средствами Html хэлперов было неудобно. В некоторых представлениях применены java скрипты для обработки информации непосредственно на клиенте (например на форме выборки объявлений) и Ajax — для динамического обновления данных (для отображения результатов выборки пользователей).
    3.6 Контроллеры, как уже говорилось ранее, в своем конструкторе получают необходимые для работы сервисы и используют их в любом методе контроллера. В каждом контроллере имеется метод MessageForClient, в который передаются сообщения для пользователя с соответствующим статусом выполняемой операции. Для передачи информации в представление используется … . Отображение сообщений происходит при перезагрузке Layout вызовом модального окна с передачей ему необходимых данных. Так же контроллеры берут на себя ответственность по подготовке моделей для репозитория. Т.е. в репозиторий направляются уже подготовленные для хранилища модели. Соответственно из репозитория контроллеры получают модели НЕ подготовленные для отображения. В контроллерах реализовано ограничение доступа как к контроллерам в целом ([Authorizen]), так и к отдельным методам (в соответствии с ролями).
    3.7 Добавлен класс General, в котором находятся некоторые «справочные» данные, используемые в проекте.
    3.8 Для работы с ролями был переопределен класс RoleProvider как CustomRoleProvider.
    3.9 Реализована аутентификация в режиме Forms.

    В качестве резюме хотел бы написать что именно я бы добавил, если бы данный проект был коммерческим, предназначенным для практического применения:
    1 — Переопределение системы аутентификации;
    2 — Реализацию ролей в качестве отдельной сущности со свойствами типа bool , обеспечивающими более удобную работу с разрешениями для конкретных ролей.;
    3 — Задумался бы в сторону асинхронности методов работы методов репозиториев для обмена данными с хранилищем. 
</p>
